{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"Project Motivation \u00b6","title":"About"},{"location":"about/#project-motivation","text":"","title":"Project Motivation"},{"location":"pyramid/","text":"Important Classes \u00b6","title":"Pyramid"},{"location":"pyramid/#important-classes","text":"","title":"Important Classes"},{"location":"workflow/annotating/","text":"Synopsis \u00b6 Transformer based approach Inline Annotation Generation \u00b6 If the trace data does not contain a type hint, but the original has an annotation, this can be retained by XXX. Bonus: Stub File Generation \u00b6 \u00b6 Developer Documentation \u00b6","title":"Annotating"},{"location":"workflow/annotating/#synopsis","text":"Transformer based approach","title":"Synopsis"},{"location":"workflow/annotating/#inline-annotation-generation","text":"If the trace data does not contain a type hint, but the original has an annotation, this can be retained by XXX.","title":"Inline Annotation Generation"},{"location":"workflow/annotating/#bonus-stub-file-generation","text":"","title":"Bonus: Stub File Generation"},{"location":"workflow/annotating/#_1","text":"","title":""},{"location":"workflow/annotating/#developer-documentation","text":"","title":"Developer Documentation"},{"location":"workflow/evaluating/","text":"","title":"Evaluating"},{"location":"workflow/fetching/","text":"Foundations & Principles \u00b6 Modify given codebase by detecting test folders and applying decorator for tracing to test functions Supported Formats \u00b6 Git repository Local folder Archives Decorator Application \u00b6 Developer Documentation \u00b6","title":"Fetching"},{"location":"workflow/fetching/#foundations-principles","text":"Modify given codebase by detecting test folders and applying decorator for tracing to test functions","title":"Foundations &amp; Principles"},{"location":"workflow/fetching/#supported-formats","text":"Git repository Local folder Archives","title":"Supported Formats"},{"location":"workflow/fetching/#decorator-application","text":"","title":"Decorator Application"},{"location":"workflow/fetching/#developer-documentation","text":"","title":"Developer Documentation"},{"location":"workflow/tracing/","text":"Foundations & Principles \u00b6 sys.settrace \u00b6 sys.settrace is a Python function that allows a callable to be set that is invoked on every line of Python code that comes after it. This registered callable, henceforth refered to as the trace function is expected to have three arguments: frame : a representation of the current stack frame, containing references to further execution-related objects, such as: the previous frame visible globals variables that have been placed on the stack and more event : a string indicating the manner in which the current line of Python is handled. Relevant for us are: call: a callable was entered line: plain line of code that is about to be executed (NOTE: this means the line will executed in the next interpreter step, not when it is encountered by the trace function) return: a callable is about to return arg : a value that differs depending on the given event. Relevant for us are: call: arg is None. Retrieving the values of arguments is to be performed separately. line: arg is None. Retrieving the values of variables on this line is also to be performed separately. return: arg is the value that will be returned from the callable. Effect on Coverage, Debugging and other trace-related Tooling \u00b6 While this approach is very powerful, it comes at a detriment to the development process. pdb , which is the Python debugger, uses the sys.settrace API to provide information during debugging sesesions. Similarly, the coverage tool, which provides code-coverage information of Python programs, also uses this entrypoint. sys.settrace only allows for one trace function to be set, meaning no tooling that also uses this API can coexist with another. Therefore, along a codepath that uses the entrypoint in question, determining code coverage, or attempting to debug, is simply not possible. API \u00b6 The project implements the required functionalities in the tracing module, in the classes of Tracer and TraceBatchUpdate , which trace and collect instances into a DataFrame by the following schema: Column Meaning Type Null? Filename Relative path to file of traced instance from project root string Never ClassModule Module of class traced instance is in string When not in a class' scope Class Name of class traced instance is in string When not in a class' scope FunctionName Name of function traced instance is in string When not in a function's scope LineNo Line number traced instance occurs on uint Never Category Number identifying context traced instance appears in int Never VarName Name of traced instance string Never TypeModule Module of traced instance's type string When the type is builtin Type Name of traced instance's type string Never Category can take on 5 different values, which are contained in the TraceDataCategory enum class: LOCAL_VARIABLE , GLOBAL_VARIABLE , CLASS_MEMBER , FUNCTION_PARAMETER and FUNCTION_RETURN . Tracer - Setting sys.settrace and Collecting Data \u00b6 The events generated by sys.settrace are caught in the Tracer class' _on_trace_is_called method when its start_trace method has been called. This ends when its end_trace method being called. This functionality has again been wrapped in its active_trace method, which can be used in Python's with statements. These methods are called from the decorators.trace function, as documented in the previous section. The implementation backs-up any previously set trace function by reading from sys.gettrace , and sets its own using sys.settrace . This newly set trace function handles the call , line and return events, and ignores the exception and opcode events, as no relevant data can be gleamed from these. Each event is handled in its own appropriately named method, and the tracer combines the DataFrame s generated by BatchTraceUpdate . When tracing is halted, the DataFrame is deduplicated to remove redundant information and the old trace function is restored. BatchTraceUpdate - Simplifying and Batching Trace Updates \u00b6 Despite the events emitted by sys.settrace being disjunct, the operations that must be performed on the basis thereof are not. For example, the handling of the return event is a superset of that of the line event. Furthermore, the line event must perform update operations for both local and global variables. Also, the general functionality necessary to update the DataFrame is repetitive, especially with FileName , ClassModule , Class and FunctionName being identical for every trace call within the same function. The BatchTraceUpdate class was designed to solve these issues; the aforementioned repetitive data is passed to the constructor, to be reused in its methods. These methods form a builder-pattern style interface for each relevant category, allowing updates to be chained as each event requires. After all updates have been handled, a DataFrame can be produced that is to added to the otherwise accumulated trace data.","title":"Tracing"},{"location":"workflow/tracing/#foundations-principles","text":"","title":"Foundations &amp; Principles"},{"location":"workflow/tracing/#syssettrace","text":"sys.settrace is a Python function that allows a callable to be set that is invoked on every line of Python code that comes after it. This registered callable, henceforth refered to as the trace function is expected to have three arguments: frame : a representation of the current stack frame, containing references to further execution-related objects, such as: the previous frame visible globals variables that have been placed on the stack and more event : a string indicating the manner in which the current line of Python is handled. Relevant for us are: call: a callable was entered line: plain line of code that is about to be executed (NOTE: this means the line will executed in the next interpreter step, not when it is encountered by the trace function) return: a callable is about to return arg : a value that differs depending on the given event. Relevant for us are: call: arg is None. Retrieving the values of arguments is to be performed separately. line: arg is None. Retrieving the values of variables on this line is also to be performed separately. return: arg is the value that will be returned from the callable.","title":"sys.settrace"},{"location":"workflow/tracing/#effect-on-coverage-debugging-and-other-trace-related-tooling","text":"While this approach is very powerful, it comes at a detriment to the development process. pdb , which is the Python debugger, uses the sys.settrace API to provide information during debugging sesesions. Similarly, the coverage tool, which provides code-coverage information of Python programs, also uses this entrypoint. sys.settrace only allows for one trace function to be set, meaning no tooling that also uses this API can coexist with another. Therefore, along a codepath that uses the entrypoint in question, determining code coverage, or attempting to debug, is simply not possible.","title":"Effect on Coverage, Debugging and other trace-related Tooling"},{"location":"workflow/tracing/#api","text":"The project implements the required functionalities in the tracing module, in the classes of Tracer and TraceBatchUpdate , which trace and collect instances into a DataFrame by the following schema: Column Meaning Type Null? Filename Relative path to file of traced instance from project root string Never ClassModule Module of class traced instance is in string When not in a class' scope Class Name of class traced instance is in string When not in a class' scope FunctionName Name of function traced instance is in string When not in a function's scope LineNo Line number traced instance occurs on uint Never Category Number identifying context traced instance appears in int Never VarName Name of traced instance string Never TypeModule Module of traced instance's type string When the type is builtin Type Name of traced instance's type string Never Category can take on 5 different values, which are contained in the TraceDataCategory enum class: LOCAL_VARIABLE , GLOBAL_VARIABLE , CLASS_MEMBER , FUNCTION_PARAMETER and FUNCTION_RETURN .","title":"API"},{"location":"workflow/tracing/#tracer-setting-syssettrace-and-collecting-data","text":"The events generated by sys.settrace are caught in the Tracer class' _on_trace_is_called method when its start_trace method has been called. This ends when its end_trace method being called. This functionality has again been wrapped in its active_trace method, which can be used in Python's with statements. These methods are called from the decorators.trace function, as documented in the previous section. The implementation backs-up any previously set trace function by reading from sys.gettrace , and sets its own using sys.settrace . This newly set trace function handles the call , line and return events, and ignores the exception and opcode events, as no relevant data can be gleamed from these. Each event is handled in its own appropriately named method, and the tracer combines the DataFrame s generated by BatchTraceUpdate . When tracing is halted, the DataFrame is deduplicated to remove redundant information and the old trace function is restored.","title":"Tracer - Setting sys.settrace and Collecting Data"},{"location":"workflow/tracing/#batchtraceupdate-simplifying-and-batching-trace-updates","text":"Despite the events emitted by sys.settrace being disjunct, the operations that must be performed on the basis thereof are not. For example, the handling of the return event is a superset of that of the line event. Furthermore, the line event must perform update operations for both local and global variables. Also, the general functionality necessary to update the DataFrame is repetitive, especially with FileName , ClassModule , Class and FunctionName being identical for every trace call within the same function. The BatchTraceUpdate class was designed to solve these issues; the aforementioned repetitive data is passed to the constructor, to be reused in its methods. These methods form a builder-pattern style interface for each relevant category, allowing updates to be chained as each event requires. After all updates have been handled, a DataFrame can be produced that is to added to the otherwise accumulated trace data.","title":"BatchTraceUpdate - Simplifying and Batching Trace Updates"}]}